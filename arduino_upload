// Sentro Knitting Machine Controller - Arduino Code
// Controls NEMA 17 stepper motor via DRV8825/A4988 driver
// Compatible with Python Knitting Machine Controller
//
// IMPORTANT: This Arduino code sends confirmation responses ("OK" or "DONE")
// that the Python script waits for before sending the next command.
// This ensures proper synchronization with the knitting machine.

// Pin definitions
const int stepPin = 2;
const int dirPin = 3;
const int enablePin = 4;  // Optional - connect to ENABLE on driver

// HC-SR04 Ultrasonic Sensor pins
const int trigPin = 7;
const int echoPin = 8;

// Motor configuration
const int stepsPerRevolution = 200;  // Standard NEMA 17 (1.8° per step)
int microstepping = 1;               // Set based on your driver jumpers (1,2,4,8,16,32)
int motorSpeed = 1000;               // Delay in microseconds between steps (lower = faster)

// HC-SR04 configuration
long distance = 0;                   // Current distance reading in cm
int needleCount = 0;                 // Count of detected needles

// Variables for serial communication - use char array instead of String
char inputBuffer[32];  // Reduced buffer size
int bufferIndex = 0;
boolean stringComplete = false;

void setup() {
  // Initialize motor pins
  pinMode(stepPin, OUTPUT);
  pinMode(dirPin, OUTPUT);
  pinMode(enablePin, OUTPUT);
  
  // Initialize HC-SR04 pins
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
  
  // Enable the motor driver (LOW = enabled)
  digitalWrite(enablePin, LOW);
  
  // Initialize serial communication
  Serial.begin(9600);
  Serial.println(F("=== Sentro Controller ==="));
  Serial.println(F("Arduino ready"));
  Serial.println(F("HC-SR04 initialized"));
  Serial.println(F("Commands: TURN/REV/SPEED/MICRO/WAIT/DISTANCE/NEEDLE_COUNT/RESET_COUNT/STOP/STATUS"));
  
  // Clear input buffer
  memset(inputBuffer, 0, sizeof(inputBuffer));
  
  Serial.println(F("Ready"));
}

void loop() {
  // Check for serial commands
  if (stringComplete) {
    processCommand();
    bufferIndex = 0;
    memset(inputBuffer, 0, sizeof(inputBuffer));
    stringComplete = false;
  }
  
  // Read serial input character by character
  while (Serial.available() > 0) {
    char inChar = (char)Serial.read();
    
    if (inChar == '\n' || inChar == '\r') {
      if (bufferIndex > 0) {
        inputBuffer[bufferIndex] = '\0';  // Null terminate
        stringComplete = true;
        break;
      }
    } else if (bufferIndex < sizeof(inputBuffer) - 1) {
      inputBuffer[bufferIndex] = inChar;
      bufferIndex++;
    }
  }
}

// Serial event handler - Not used since we handle it in main loop
// Note: serialEvent() doesn't work on all Arduino boards reliably
/*
void serialEvent() {
  while (Serial.available()) {
    char inChar = (char)Serial.read();
    inputString += inChar;
    if (inChar == '\n') {
      stringComplete = true;
    }
  }
}
*/

void processCommand() {
  // Convert to uppercase for comparison
  for (int i = 0; i < bufferIndex; i++) {
    if (inputBuffer[i] >= 'a' && inputBuffer[i] <= 'z') {
      inputBuffer[i] = inputBuffer[i] - 32;
    }
  }
  
  // Debug: Show received command
  Serial.print(F("DEBUG: Command: "));
  Serial.println(inputBuffer);
  
  if (strncmp(inputBuffer, "TURN:", 5) == 0) {
    // Parse TURN:steps:direction
    char* stepStr = inputBuffer + 5;
    char* dirStr = strchr(stepStr, ':');
    
    if (dirStr != NULL) {
      *dirStr = '\0';  // Null terminate step string
      dirStr++;        // Move to direction
      
      int steps = atoi(stepStr);
      bool isClockwise = (strcmp(dirStr, "CW") == 0);
      
      if (steps > 0 && (strcmp(dirStr, "CW") == 0 || strcmp(dirStr, "CCW") == 0)) {
        Serial.print(F("Turn "));
        Serial.print(steps);
        Serial.print(F(" steps "));
        Serial.println(dirStr);
        turnSteps(steps, isClockwise);
        Serial.println(F("DONE"));
      } else {
        Serial.println(F("ERROR: Invalid TURN"));
      }
    } else {
      Serial.println(F("ERROR: Invalid TURN format"));
    }
  }
  
  else if (strncmp(inputBuffer, "REV:", 4) == 0) {
    // Parse REV:revolutions:direction
    char* revStr = inputBuffer + 4;
    char* dirStr = strchr(revStr, ':');
    
    if (dirStr != NULL) {
      *dirStr = '\0';
      dirStr++;
      
      float revolutions = atof(revStr);
      bool isClockwise = (strcmp(dirStr, "CW") == 0);
      
      if (revolutions > 0 && (strcmp(dirStr, "CW") == 0 || strcmp(dirStr, "CCW") == 0)) {
        int totalSteps = revolutions * stepsPerRevolution * microstepping;
        Serial.print(revolutions);
        Serial.print(F(" rev ("));
        Serial.print(totalSteps);
        Serial.print(F(" steps) "));
        Serial.println(dirStr);
        turnSteps(totalSteps, isClockwise);
        Serial.println(F("DONE"));
      } else {
        Serial.println(F("ERROR: Invalid REV"));
      }
    } else {
      Serial.println(F("ERROR: Invalid REV format"));
    }
  }
  
  else if (strncmp(inputBuffer, "SPEED:", 6) == 0) {
    int newSpeed = atoi(inputBuffer + 6);
    if (newSpeed >= 500 && newSpeed <= 3000) {
      motorSpeed = newSpeed;
      Serial.print(F("Speed: "));
      Serial.println(motorSpeed);
      Serial.println(F("OK"));
    } else {
      Serial.println(F("ERROR: Speed 500-3000"));
    }
  }
  
  else if (strncmp(inputBuffer, "MICRO:", 6) == 0) {
    int newMicro = atoi(inputBuffer + 6);
    if (newMicro == 1 || newMicro == 2 || newMicro == 4 || newMicro == 8 || newMicro == 16 || newMicro == 32) {
      microstepping = newMicro;
      Serial.print(F("Microstepping: 1/"));
      Serial.println(microstepping);
      Serial.println(F("OK"));
    } else {
      Serial.println(F("ERROR: Micro 1,2,4,8,16,32"));
    }
  }
  
  else if (strncmp(inputBuffer, "WAIT:", 5) == 0) {
    float waitTime = atof(inputBuffer + 5);
    if (waitTime >= 0 && waitTime <= 60) {
      Serial.print(F("Wait "));
      Serial.println(waitTime);
      delay(waitTime * 1000);
      Serial.println(F("DONE"));
    } else {
      Serial.println(F("ERROR: Wait 0-60"));
    }
  }
  
  else if (strcmp(inputBuffer, "STOP") == 0) {
    Serial.println(F("STOP"));
    digitalWrite(enablePin, HIGH);
    delay(100);
    digitalWrite(enablePin, LOW);
    Serial.println(F("OK"));
  }
  
  else if (strcmp(inputBuffer, "STATUS") == 0) {
    Serial.println(F("=== Status ==="));
    Serial.print(F("Steps/rev: "));
    Serial.println(stepsPerRevolution);
    Serial.print(F("Micro: 1/"));
    Serial.println(microstepping);
    Serial.print(F("Speed: "));
    Serial.println(motorSpeed);
    Serial.print(F("Distance: "));
    Serial.print(measureDistance());
    Serial.println(F(" cm"));
    Serial.print(F("Needles: "));
    Serial.println(needleCount);
    Serial.println(F("OK"));
  }
  
  else if (strcmp(inputBuffer, "DISTANCE") == 0) {
    long currentDistance = measureDistance();
    if (currentDistance >= 0) {
      Serial.print(F("Distance: "));
      Serial.print(currentDistance);
      Serial.println(F(" cm"));
    } else {
      Serial.println(F("Distance: ERROR"));
    }
    Serial.println(F("OK"));
  }
  
  else if (strcmp(inputBuffer, "NEEDLE_COUNT") == 0) {
    Serial.print(F("Needle count: "));
    Serial.println(needleCount);
    Serial.println(F("OK"));
  }
  
  else if (strcmp(inputBuffer, "RESET_COUNT") == 0) {
    needleCount = 0;
    Serial.println(F("Count reset"));
    Serial.println(F("OK"));
  }
  
  else {
    Serial.print(F("ERROR: Unknown - "));
    Serial.println(inputBuffer);
  }
}

void turnSteps(int steps, boolean clockwise) {
  // Set direction
  digitalWrite(dirPin, clockwise ? HIGH : LOW);
  
  // Small delay to ensure direction is set
  delayMicroseconds(10);
  
  // Perform steps with progress indication
  for (int i = 0; i < steps; i++) {
    digitalWrite(stepPin, HIGH);
    delayMicroseconds(motorSpeed / 2);
    digitalWrite(stepPin, LOW);
    delayMicroseconds(motorSpeed / 2);
    
    // Progress indication for long operations - reduced frequency
    if (steps > 2000 && i % 1000 == 0 && i > 0) {
      Serial.print(F("Progress: "));
      Serial.print(i);
      Serial.print(F("/"));
      Serial.println(steps);
    }
    
    // Check for emergency stop every 200 steps - reduced frequency
    if (i % 200 == 0 && Serial.available()) {
      char emergencyBuffer[8];
      int emergencyIndex = 0;
      
      while (Serial.available() && emergencyIndex < 7) {
        char c = Serial.read();
        if (c >= 'a' && c <= 'z') c = c - 32;  // Convert to uppercase
        emergencyBuffer[emergencyIndex++] = c;
        if (c == '\n' || c == '\r') break;
      }
      emergencyBuffer[emergencyIndex] = '\0';
      
      if (strcmp(emergencyBuffer, "STOP") == 0) {
        Serial.print(F("STOP at step "));
        Serial.print(i);
        Serial.print(F("/"));
        Serial.println(steps);
        return;
      }
    }
  }
}

long measureDistance() {
  // Clear the trigPin
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  
  // Set the trigPin HIGH for 10 microseconds
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  
  // Read the echoPin, returns the sound wave travel time in microseconds
  long duration = pulseIn(echoPin, HIGH, 30000); // 30ms timeout
  
  // Calculate the distance in centimeters
  long distance_cm;
  
  if (duration == 0) {
    // Timeout occurred
    Serial.println(F("DEBUG: HC-SR04 timeout"));
    distance_cm = -1;
  } else if (duration < 150) {
    // Too close reading
    Serial.println(F("DEBUG: HC-SR04 too close"));
    distance_cm = -2;
  } else {
    distance_cm = (duration * 343) / 20000;  // Simplified calculation, avoid float
    Serial.print(F("DEBUG: duration="));
    Serial.print(duration);
    Serial.print(F("μs, dist="));
    Serial.print(distance_cm);
    Serial.println(F("cm"));
  }
  
  return distance_cm;
}
